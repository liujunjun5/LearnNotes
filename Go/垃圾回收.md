## 什么是垃圾回收
对不需要使用的对象进行清理
## 垃圾回收的常见算法
- 标记清理
  - 优点：简单快
  - 缺点：内存碎片
- 标记整理
  - 优点：不会出现碎片
  - 缺点：删除过多的对象会大量的移动
- 复制算法
    - 优点：不会碎片
    - 缺点：剩余过多内存消耗大
- 分代算法
  - 将内存分为新生代/老年代
  - 新生代进行复制算法/老年代进行标记整理算法

## Go中的垃圾回收
### 为什么不适用分代/标记清除
TCmalloc模型不会产生过大的内存碎片——不适合标记清除
对于短生命周期的对象逃逸分析不会放在堆中，放在栈中，整体来说不大容易出现长短差异大的对象
### 三色标记
将对象分为白（垃圾）、灰（待检查）、黑（已检查且需要留下）
堆中使用了插入屏障/删除屏障 避免STW，但是栈中无法使用需要STW
### 插入/删除写屏障
所有新的引用置为灰色（STW，栈问题），所有新的删除置为灰色（下一轮处理，精度问题，也需要STW，可以改进，一个一个栈处理）
### 混合屏障
堆中维系插入/删除写屏障，栈中每一个新增/删除改为黑色，而且

## 根对象有哪些
- 栈对象
- 常量
- 全局变量
## STW是什么
用户程序被停止
## 标记清除算法的难点是什么
- 新增的对象
- 引用改变
## GO如何解决标记清除算法，清除时，用户程序并发引起的引用问题
少量的STW时间启动STW
## 什么是写屏障、混合写屏障

## 如何处理栈

## GO的GC流程
- STW准备
- 标记
- STW收尾
- 清理
## GC的触发时机
- 手动触发
- 2min
- 内存阈值
## GC关注的指标
- GC次数
- GC停顿时间
- GC时CPU负载
- 内存中对象存活大小
## 有了GC为什么还会发生内存泄漏

## GC如何调优
- GOGC 大-停顿久清楚多次数少
- GCMenLimit 控制内存上限
### 代码
- 复用
- 逃逸
- 全局变量减少
## 如何观察GC
- 测试/编码——开启GClog
- pprof，生成内存和CPU使用情况
- 生产环境集成中间件
