# 宏观
## 进程 and 协程
- 进程：活跃在内核态，类似于正式员工，入职繁琐但是权限高，资源多
- 协程：活跃在用户态，类似于外包员工，快速入职，权限少，调动简单
## GMP数据流程
G 创建，放入创建它的P队列中，如果P队列已经满了放入全局队列。 P和M一般是一对一绑定，M是内核进程的抽象，负责实际的任务执行，P负责分配资源和分配任务，G则是任务单元，有自己的栈空间、生命周期，go关键字后的函数即是需要执行的任务  
P 会将队列中的G分配给M，如果P没有G，会从全局队列拉取任务，如果全局任务也没有则会进行任务窃取从其他的P队列后去G（一半，且是队列末尾）
## GMP的数据结构
### **G**
- 栈
- 栈临界值
- defer
- panic
- 状态
- M
### **M**
- P
- g0
- curg
### **P**
- m
- 状态
- 本地队列
- 收尾指针
### **全局调度器**
- 空闲P队列
- 空闲M队列
- 全局G队列
- G个数
- 锁

## 微观
### G的创建
#### main
main函数是一个特殊的g，有m0创建，绑定g0，初始化P（process）  
将m0绑定到P，将main封装为一个g，放入P中交由M0调度，完事以后m0变成普通的m
#### g的创建
1. go func()代表一个go任务提交
2. 放入当前g的p队列中如果p满了放入全局队列中
3. 尝试nextrun优先位置
4. g0进行调度设置状态和当前g
5. 将g0转为g
6. 有空闲的p and 无自旋的M则会唤醒p
#### p的唤醒
runnablefind查找任务  
1. 本地队列有无任务
2. 全局队列有无任务（61次调用后进行防止饥饿）
3. 检查全局队列
4. 非阻塞式检查io队列
5. 工作窃取
6. 阻塞式检查io
7. 最后全局队列检查
8. 休眠
### G的出让
这里是指主动的出让，主要三种情况
1. 完成执行
  - 转为g0
  - g0收尾，将g转为gdead，回收栈空间，数据结构还给freeg
  - g0查找下一个g
2. 系统调用（非阻塞式G级别的调用——网络io，mutex，channel）
  - 调用gopark G被设置为gwait状态
  - 解绑G和M
  - M执行其他的G
  - G交由上层调用方（mutex/channel/网络io）
  - 完成以后goready
  - G变成goread变回队列中
3. 主动出让
  - yield
  - g0将g变成grunable
  - 回到p队列
### 抢占式调度
主要是阻塞调用、运行时间过长
1. 阻塞调用（发生在文件io、sleep中）
   - 解绑G和M
   - 将G、P都设置为syscall
   - 将M设置为阻塞，保存pmap
   - P被监控到10ms空闲则会执行其他的
   - m existCall以后看p是否空闲，判断是继续还是换一个p绑定
2. 长时间运行调度
   - 运行时间过长早期协作式————标记，函数调用时检查，但是没法处理不调用函数的
   - g1.14以后加入非协作式，即标记，发送操作系统的信号，由他强制退出，更改程序计数器
