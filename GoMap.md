## 常见的hash冲突处理
### 拉链法
### 开放地址寻址法
### Go map的处理

## Map的数据结构
### hmap
- count
- bmap
- oldbmap
- 迁移数
- 溢出桶数
- 溢出桶地址
- B
- hash0
### bmap
本质上是一个二维数组
- tophash
-- tophash 本质上是uint8数组，计算时+5，小5位是状态位
- key
- value
- 溢出桶地址
以key-key value-value方式存储——内存对齐

## Map的查询/赋值
### 查询
1. map为nil or empty
2. map在写？fetal error
3. 计算hash
4. 掩码计算槽位
5. 是否迁移？判断是去新or旧
6. 前8位tophash对比
7. 不一致——判断tophash的标志位是否有后继空状态 一致——判断key
8. key一致返回，不一致后续空状态？

### 赋值
1. nil or empty
2. 写？
3. 计算hash+掩码
4. 是否初始化
5. 是否扩容，是的话且当前槽位迁移+额外一个槽位
6. 遍历tophash 不一致——1.空？候选 2.后继空插入 3.有值下一个
7. tophash一致判断key，一致判断修改 不一致下一个槽位
8. 如果没有槽位插入溢出桶
9. 最后消除写标志
## Map的扩容过程
### hasgrow
创建内存区域，将oldbuckets挂载
发生了赋值操作且满足扩容条件会触发
### growwork
做迁移
在增删改操作时会触发
1. 迁移该桶和随机一个桶
2. 判断是否被迁移过？
3. 遍历每一个槽位移动到合适的位置
4. 完成以后标志位加一

分为等量迁移（溢出桶太多——B<15时，溢出桶≥2^B；B≥15时，溢出桶≥2^15）和双倍迁移（超过6.5阈值，key/value对 / 桶）

## Map删除键值对
类似于查找，多了tophash标志位的修改
## Map遍历流程
使用迭代器完成的
基本流程：
1. 判断是否在写流程中，是的话panic
2. 设置遍历中
3. 随机选择一个桶下标和槽下标
4. 判断是否在扩容中，是的话遍历旧桶可以hash到原桶的
5. 遍历溢出桶
6. 修改遍历完成
