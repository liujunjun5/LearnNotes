#  概念
## Java的特点
+ 平台无关性：即一次编译，到处运行
    - Java编译器将源代码编译成字节码，该字节码可以在任何安装了Java虚拟机的系统上运行。
+ 面向对象编程：将事物抽象成为对象，对象具有属性和行为。
    - 面相对象的特性使得代码更易于维护和重用，包括类、对象、继承、多态、抽象和封装。
+ 内存管理：有着自动垃圾回收机制，无需程序员手动进行垃圾回收，自动管理内存和回收不再使用的对象，减少了内存溢出和内存泄漏等问题。



## Java的优势和劣势
### 优势
+ 一次编写，到处运行。
+ 是面向对象编程，有着强大的生态（如Java SPring等），社区支持，企业应用广泛。
+ 内存管理：拥有自动垃圾回收机制。
+ 支持多线程，内置线程机制，方便并发编程。
+ Java的安全模型：如沙箱机制，适合网络环境
+ 稳定性较好：企业级应用长期使用，版本更新也较注重向后兼容

### 劣势
+ 性能开销较大，启动时间较长（如在微服务场景下）
+ 语言繁琐，虽然有了lambda编程，但还是不如Python简洁。
+ 内存消耗：JVM本身也是占用内存，对于资源有限的环境可能不太友好。
+ 还有面向对象过于严格，有时候写简单程序反而麻烦，虽然在Java8以后引入了函数式编程，但不如其他语言自然。
+ 开发效率可能不如动态语言（如Python，Java需要更多的代码），编译过程也可能拖慢开发节奏。



## Java为什么是跨平台的
Java支持跨平台，主要依赖于JVM

+ JVM是一个软件，在不同的平台上又不同的版本。Java源码经过编译后会生成一种字节码.class文件，JVM可以将字节码翻译为特定平台下的机器码，然后运行。



## JVM、JDK、JRE三者关系
JDK包含JRE，JRE包含JVM

+ JVM：JVM是Java虚拟机，是Java程序运行的环境，将Java字节码解释或编译为机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java具有跨平台性。
+ JDK是Java开发工具包，是开发Java所需要的工具集合。他包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具。
+ JRE是Java程序运行所需要的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含 开发工具，只提供Java程序运行所需的运行环境。



## JVM和Java有什么区别
+ Java是编程语言，而JVM是平台。一个是写代码的工具，一个是跑代码的环境。二者分工不同但相互配合。
    - 即Java是一门编程语言，JVM是用来运行Java程序的一个平台或者是运行环境。
    - JVM不止能够运行Java。因为JVM执行的是字节码，所以想Kotlin/Scala这些语言，虽然在语法上跟Java不一样，但是在编译后也是生成Java字节码，同样可以在JVM上运行。故JVM现在已经不是Java专属了，而是整个JVM语言生态的基础平台。



## 为什么Java解释和编译都有
首先Java在经过编译后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。

+ 编译性：Java源代码首先被编译成字节码，JIT会把编译过的机器码保存起来，以备下次使用
+ 解释性：JVM中一个方法调用计数器，当累计计数大于一定值的时候，就是用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。

故Java既是编译型也是解释型语言，默认采用的是解释器和编译器混合的模式。



## JVM是什么
JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。

JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行“的原因。



## 编译型语言和解释型语言的区别？
编译型语言和解释型语言的区别在于：

+ 编译型语言：在程序执行之前，整个源代码会被编译成字节码或是机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性差
+ 解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行文件，跨平台性好，但执行速度相对较慢。



## Python和Java区别是什么？
+ Python是解释型语言，在执行时会逐行解释代码并执行
+ Java是一种已编译型的编程语言，会编译生成字节码文件，在将文件交由JVM虚拟机执行。



## 值传递和引用传递的区别？
在Java中，参数传递只有值传递，不存在真正的“应用传递”，核心区别在于传递的是“值的副本”，还是“引用的副本”。

+ 值传递传递的是实际值的副本，适用于基本数据类型，修改方法内的参数副本，并不会影响原变量的值。
+ 引用传递传递的是对象的引用副本，这两个引用都是指向同一个对象，因此通过副本修改对象内部数据，会影响原对象。但如果修改副本引用的指向（如重新赋值），则不会影响原引用的指向。

简单来说，Java的所有参数传递都是值传递：

+ 基本数据类型传递“值传递”，修改副本不影响原值。
+ 引用类型传递“引用副本”，通过副本可修改对象内容，但无法修改原引用的指向。



# 数据类型
## 八种基本数据类型
Java支持的数据类型可以分为两类：基本数据类型和引用数据类型

基本数据类型分为八种，可以分为三类：

+ 数值型：
    - 正数类型：byte ，short，int，long
    - 浮点数类型：float，double
+ 字符型：char
+ 布尔型：boolean

补充：

| 数据类型 | 占用大小 | 位数 | 取值范围 | 默认值 | 描述 |
| --- | --- | --- | --- | --- | --- |
| byte<br/> | 1 | 8 | -2^7~(2^7-1) | 0 | 是最小的整数类型，适用于节省内存，如在处理文件或网络流时存储小范围整数数据<br/> |
| short | 2 | 16 | -2^16~2^16-1 | 0 | 较少使用，通常用于在需要节省内存且数值范围在该区间的场景 |
| int | 4 | 32 | -2^32~2^32-1 | 0 | 最常用的整数类型，可满足大多数日常编程中整数计算的需求 |
| long | 8 | 64 | -2^64~2^641 | 0L | 用于表示非常大的整数，当int类型无法满足需求时使用，定义时数值后需加L或l |
| float | 4 | 32 | 1.4E-45到3.4028235E38 | 0.0f | 单精度浮点数，用于表示小数，精度相对较低，定义时数值后需加F或f |
| double | 8 | 64 | 4.9E-324~1.7976931348623157E308 | 0.0d | 双精度浮点数，精度比float高，Java中表示小数的默认类型 |
| char | 2 | 16 | ‘\u0000'(0)~'\uffff'(65535) | '\u0000' | 用于表示单个字符，采用Unicode编码，可表示各种语言的字符。 |
| boolean | 无明确字节大小（理论上1位） | 无明确位数 | true或false | false | 用于逻辑判断，只用两个取值，常用于条件判断和循环控制等逻辑场景 |


注意：八种基本数据类型的包装类：除了char的时Character、int类型的Integer，其他都是首字母大写。



## int和long是多少位，多少字节的
int是32位，4字节；long是64位，8字节。

二者都是有符号的。



## long和int可以相互转换吗?
可以的，Java中的long和int是可以相互转换的。由于long类型的范围比int类型大，故将int转换为long是安全的，将long类型转换为int类型可能会导致数据丢失或溢出。

将int类型转换位long可以直接赋值或强制类型转换来来实现。

将long类型转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。



## 数据类型转换方式有哪些？
+ 自动类型转换：如将int类型转换为long类型，就可以直接赋值
+ 强制类型转换：如将long类型转换为int类型，就需要使用强制类型转换
+ <font style="color:#DF2A3F;">字符串转换：Java提供了将字符串转换为其他数值类型的方法。</font>
+ <font style="color:#DF2A3F;">数值之间的转换：Java提供了一些数值之间的转换方法，如将整数类型转换为字符型，将字符型装换位数值型</font>

<font style="color:#DF2A3F;"></font>

## <font style="color:#000000;">类型互转会出现什么问题</font>
1. 基本数据类型之间的转换可能会出现数据丢失、数据溢出或精度损失。
2. <u>应用对象之间的转换可能会出现的问题：向上转换是自动进行的，而且是安全的；向下转换需要手动进行，并且存在风险（当进行向下转型时，Java会检查是否与目标类型兼容。如果不兼容，就会抛出Class CastException）。需要使用instanceof进行检查</u>

<u></u>

## 为什么用bigDecimal不用douoble
+ double会出现精度丢失问题，double执行的是二进制浮点运算，即二进制表示小数时只能够表示能够用1/（2^n）之和的任意组合，故他无法很好的表示0.1这种小数，因为0.1不能够表示成为1/（2^n）之和的形式，就像十进制无法准确的表示三分之一。
+ 而bigDecimal是精确计算，一般牵扯到金钱的计算，都是使用Decimal，使用Big Decimal可以确保十进制的数值计算，避免了使用double可能出现的舍入误差，但需要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数作为参数，以避免精度丢失。



## 装箱和拆箱是什么
装箱是将方法和属性进行封装，拆箱则是与之相反的操作。将int类型转换位Integer包装类，是装箱；将Integer包装类转换位int类型，则是拆箱。

（即装箱和拆箱是将基本数据类型和对应的包装类之间进行转换的过程。）

补充：

+ 自动装箱主要发生在两种情况，一种是赋值时（所有转换都是编译器来完成），另外一种是在方法调用时（在调用方法时，我们可以传入原始的数据类型，或者时对象，编译器会帮我们进行转换）。
+ 自动装箱的弊端，在一个循环中进行自动装箱操作的情况下，可能会创建多余的对象，影响程序的性能。



## Java为什么要有Integer
（先从两个方面去思考，一是将int类型包装成Integer对象，可以把属性也就是数据和这些数据的处理方法结合在一起。另一个方面就是Java中绝大部分方法和类都是用来处理类类型对象的，就比如Array List集合类就只能以类作为他的存储对象）。

+ 一方面将int类型包装成Integer对象，可以把这些数据和处理这些数据的方法结合在一起。
+ 另一方面，就是Java中的绝大部分方法和类都是用来处理类类型对象的。主要是从一下几个方面进行说明：
    - 一个就是泛型中的引用，在Java中，泛型只能使用引用类型，而不能使用基本类型，因此，如果要在泛型中使用int类型，必须使用Integer包装类。
    - 另一个就是在转换中的应用，如果要将int类型转换位String类型，就需要先将其转换位Integer包装类，在通过Integer包装类转换位String类型。
    - 还有一个就是集合的应用，在Java集合中只能存储对象，而不能存储基本数据类型；就例如Array List集合类中只能以类作为他的存储对象。



## Integer相比int有什么优点
（可以联合Java为什么要有Integer这个问题进行联合记忆）

1. 面向对象的特性：
    1. Integer是对象，可以参与面向对象的操作（如作为方法参数传递时按引用传递）
    2. 可以调用其他方法（如Integer.parseInt（））
2. 泛型支持
    1. 可以用于集合框架（如List<Integer>），因为泛型不支持基本类型
    2. 支持作为泛型类型参数
3. 特殊值支持
    1. 可以表示null值，适用于数据可能缺失的场景（如数据库查询结果）
4. 功能扩展
    1. 提供丰富的工具方法：进制转换、比较、类型转换等
    2. 常量支持：Integer.MAX_VALUE、Integer.MIN_VALUE 
5. 自动装箱/拆箱
    1. Java5+支持与int自动转换，兼顾便利性和功能
6. 缓存优化
    1. 默认缓存-128到127的Integer对象，提高常用数值的性能

追求性能、常规计算：使用int；需要对象特性、集合操作、可能为空：使用Integer。

同时null值是无法自动拆箱的。



## 那为什么还要保留int类型
+ 一是包装类作为引用类型，对象的引用和对象本身是分开存储的，而基本类型数据、变量对应的内存块直接存储数据本身。
+ 二是基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启应用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的四倍。

综上所述，不管是读写效率，还是存储效率，基本类型，都比包装类高效。



## 说一下Integer的缓存
Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。

默认情况下，这个范围是-128到127。当通过Integer.valueOf（int）方法创建一个在这个范围内的整数对象是，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。



# 面向对象
## 怎么理解面向对象？简单说说封装继承多态
+ 面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活和可拓展性，通过封装和继承可以更好地应对需求的变化。

Java面向对象的三大特性包括：封装、继承、多态：

+ 封装：封装是指将对象的属性和行为结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互，封装的目的是增强安全性和简化编程，使得对象更加独立。
+ 继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。
+ 多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实列而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。



## 多态体现在那几个方面？
+ 一方面多态体现在对象方法的重载（在同一个类中，相同方法名，但是参数类型、个数或顺序上的不同）和重写（子类对于父类方法中的同名方法的具体实现）；
+ 另一方面多态体现在一个类可以实现多个接口 ，多个类同时实现一个接口。
+ 同时也体现在类对象的向上转型（父类类型的引用指向子类对象）和向下转型（将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免ClassCastException）。



## 多态解决了什么问题
定义：多态是指子类可以替换父类。在实际代码运行过程中，调用子类的方法实现。（多态主要是靠继承、接口类等特殊机制来实现）

多态主要解决了代码的拓展性、可维护性和可复用性，是面向对象设计的核心特性。因此，多态称为了很多设计模式、设计原则（依赖倒置原则、里氏替换原则、开闭原则）、编程技巧的代码实现基础。

具体问题：

+ 消除条件分支，提高扩展性
+ 降低耦合度，符合开闭原则
+ 实现程序的可插拔性



## 面向对象的设计原则有哪些
+ 单一职责原则（SRP）：一个类应该只负责一项职责。
+ 开放封闭原则（OCP）:软件实体应该对拓展开放，对修改封闭。
+ 里氏替换原则（LSP）：子类应该能够替换掉所有父类对象。
+ 接口隔离原则（ISP）：接口应该小而专，即客户端不应该依赖那些它不需要的接口。
+ 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖与抽象；抽象不应该依赖与细节，细节应该依赖与抽象。
+ 最少知识原则（Law of Demeter）：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。



## 重载和重写有什么区别
重载是在同一个类中，可以有多个同名的方法名，这些方法名的参数类型、个数和顺序都不相同；

重写是子类对父类方法的重新定义，方法名、参数列表和返回类型必须与父类中的方法一致。



## 抽象类与普通类区别
+ 从定义上来说：抽象类是用于定义一组相关类的共同结构，不能直接实例化，通常作为其他类的基类；普通类是用于描述具体对象的属性和行为，可以直接实例化。
+ 从方法实现上来说：抽象类可以有抽象方法，也能有具体方法，抽象方法需要子类去实现；普通类的所有方法都必须有具体的实现。
+ 在继承与多态方面上：抽象类是必须被继承的，其子类也是必须实现抽象类中的所有抽象方法；普通类可以被继承，但继承普通类时，子类可以重写父类的方法，也可以不重写。



## Java抽象类和接口的区别
+ 抽象类可以包含字段构造方法、具体方法和抽象方法，还可以包含静态方法（关键字为extends）；一个类只能继承一个抽象类；抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。
+ 接口类不能有实例字段和构造方法。可以包含抽象方法、默认方法、静态方法和常量（关键字为implements）；一个类可以实现多个接口；接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。



## 抽象类能加final修饰吗
不能，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此抽象类和final修饰付是互斥的，不能同时使用。



## 接口可以定义哪些方法
接口能够定义的方法主要有抽象方法（public、abstract）、默认方法（default）、静态方法（static）、私有方法（private）



## 抽象类可以被实例化吗
不能，抽象类只能够被继承，并不能够进行实例化，虽然抽象类也有构造器，但主要是用于子类初始化调用。



## 接口中可以包含构造函数吗？
不可以，接口不会有自己的实例的，所以不需要有构造函数。并且在接口中写入构造方法时，编译器提示：Interface.cannot.have.construcors。



## 解释Java中的静态变量和静态方法
在Java中，静态变量和静态方法都是与类本身相关联，不与类的实例（对象）相关联。其在内存中只存在一份，可以被类的所有实例共享。

+ 静态变量被static关键字声明，属于类而不是具体的对象。其主要特点为：共享性（所有该类的实例共享一个静态变量）、初始化（在类被加载时初始化，只会对其进行一次分配内存）、访问方式（可以通过类名方法，也可以通过实例访问）
+ 静态方法在类中使用static关键字声明，可以被类的所有实例调用，也可以在没有创建类实例的情况下调用。可以直接访问其他静态变量和静态方法，但是不能直接访问非静态成员；静态方法不支持重写，但可以被隐藏。

## 非静态内部类和静态内部类的区别
非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例化。

非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员

非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。

非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。

非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。



## 非静态内部类可以直接访问外部方法，编译器是怎么做到的？
非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。

这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。





# 关键字
## Java中final作用是什么？
final关键字主要是用于修饰类、方法和变量。

+ 修饰类则表示该类不能被继承
+ 修饰方法则表示这个方法不能被重写
+ 修饰变量表示该变量一旦被赋值就不能再改变

## Java中static的作用是什么？
static主要使用与修饰类的成员（如变量、方法、代码块）和内部类。

+ static修饰变量时，则表明该变量属于类本身，而非类的某个实例，该类的所有对象都共享这个变量，内存中只有一份副本。
+ 这个关键字修饰方法时，则表明该方法属于类，不依赖于类的实例。只能够访问静态成员，不能直接访问类中的非静态成员
+ 修饰代码块时，表示该代码块在类加载时执行，且只执行一次（优于对象构造方法）
+ 当其修饰内部类时，表示这个类不需要依赖外部类实例，可以独立实例化，可以读取外部类的静态成员，不能直接访问外部类的非静态成员。



# 深拷贝和浅拷贝
## 深拷贝和浅拷贝的区别
浅拷贝只复制原对象的值和引用类型的引用，修改浅拷贝所复制的副本时，原对象会受到影响，即两个对象指向的是同一个引用对像。

深拷贝则是复制原对象的值和引用类型的值，修改深拷贝所得到的副本，不会影响原对象。即深拷贝是生成一个全新的对象以及其内部的所有对象。



## 实现深拷贝的三种方法是什么？
在Java中实现深拷贝有以下三种方法：

+ 实现Cloneable接口并重写clone（）方法
+ 通过序列化和反序列化实现深拷贝，需要实现Serializeable接口
+ 手动递归复制



# 泛型
## 什么是泛型
泛型是Java里的一个关键功能，它让你在定义类、接口或方法的时候可以用一些占位符（类型参数）。等到真正用它们的时候，你可以把这些占位符换成具体的类型。这样做的好处是代码更灵活了。



补充，为什么需要泛型：

+ 适用于多种数据类型执行相同的代码
+ 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）



# 对象
## Java创建对象有哪些方式？
+ 使用New关键字
+ 使用class类的newInstance（）方法，即通过Java的反射API，在运行时动态地创建对象。需要注意的是，在JKD9以后，Class.newInstance（）方法就被标记为过时了。更多的使用Construct类的newInstance（）方法，同样是使用了反射机制。
+ 通过实现Clone类，并重写clone（）方法，实现可以基于一个现有对象（原型）创建一个新的副本对象。
+ 使用反序列化
+ 使用工厂模式-这是一个设计模式，不直接使用new，而是通过一个方法来返回对象实例。



## Java创建对象除了new还有别的什么方式？
+ 通过反序列化创建对象。
+ 使用Construct.newInstance（）方法创建对象
+ 实现Clone接口，并重写clone（）方法，来创建对象
+ 使用工厂模式来创建对象



## New出的对象什么时候回收？
通过关键字new创建的对象，有Java的垃圾回收器负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性的检测不再被引用的对象，并将其回收释放内存。



关于垃圾回收器的一些算法：

1. 引用计数法：某个对象的引用计数为0时，表示该对象不再被应用，可以被回收。
2. 可达性分析：从根对象（如方法区中的类静态属性、方法中的局部变量）出发，通过对象之间的引用链条进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
3. 终接器：如果对象重写了finalize（）方法，垃圾回收器会在回收该对象之前调用finalize（）方法，对象可以在finalize（）方法中进行一些清理操作。然而终接器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。



## 如何获取私有对象？
可以通过两种方式来间接获取私有对象：

+ 通过使用公共访问器（getter方法），如果类的设计者遵循良好的编程规范，通常会为私有变量提供公共的访问器方法（即getter方法），通过调用这些方法可以安全地获取私有对象
+ 反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过private访问修饰符的限制来获取私有对象。



# 反射
## 什么是反射
反射机制就是在运行状态中，对与任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

总而言之，反射是程序在运行时动态获取和操作自身结构的能力。



## 反射具有一下特性：
1. 运行时类信息访问
2. 动态对象的创建（Construct类的Instance方法）
3. 动态方法的调用（Method类的invoke方法实现）
4. 访问和修改字段



## 反射在平时写代码或框架中的应用场景有哪些
+ 关于使用反射创建对象
+ 动态获取类信息
+ 动态访问和修改字段值

（嗯，另一种说法：加载数据库驱动和配置文件加载）



# 注解
## 定义
注解时一种添加到程序代码（类、方法、变量、参数等）上的元数据。它本身不是程序逻辑的一部分，但可以为编译器、开发工具或运行时框架提供额外的指示信息。

## Java注解的原理
**Java注解的本质是继承自**`Annotation`**接口的接口**，具体实现类是Java运行时生成的动态代理，其原理基于：

1. **编译期处理**：注解处理器（Annotation Processor）在编译时扫描和处理注解，可生成代码或报告错误。
2. **运行时反射**：RUNTIME保留的注解在类加载时存入Class对象，通过反射API（如`getAnnotation()`）读取。
3. **字节码操作**：注解信息存储在.class文件的属性表中，可通过字节码工具（如ASM）直接读取或修改。

**关键机制**：注解本身只是元数据标记，其作用完全依赖于处理工具（编译器、框架、自定义处理器）如何解释和利用这些标记。



## 注解的类型
+ 源码级别的注解：仅存在源码中，编译后不会保留
+ 类文件级别注解：保留在.class文件中，但运行时不可见
+ 运行时注解：保留在.class文件中，并且可以通过反射在运行时访问



## 注解的底层实现
简单说明就是，注解本质是接口，运行时用动态代理封装数据返回给你。

1. 编译时：注解信息变成键值对存入class文件
2. 运行时：通过反射获取注解时，JVM 读取这些键值对
3. 返回代理：JVM创建动态代理对象，你调注解方法时返回对应的值。

解析注解的基本流程：

1. 获取注册信息：通过反射API可以获取类、方法、字段等元素上的注解。
2. 底层原理：反射机制的核心类是Java.lang.reflect.AnnotatedElement，它是所有可以被注解修饰的元素（如class、Method、Field等）的父接口。

注解解析的底层实现主要依赖于Java的反射机制和字节码文件的存储。通过@Retention元注解可以控制注解的保留策略，当使用RetentionPolicy.RUNTIME时，可以在运行时通过反射API来解析注解信息。在JVM层面，会从字节码文件中读取注解信息，并创捷注解的代理对象来获取注解的属性值。



## Java注解的作用域
补充：注解的作用域（Scope）指的是可以应用在那些程序元素上，例如类、方法、字段等。

Java注解的作用域可以分为三种

+ 类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。
+ 方法级别作用域：用于描述 方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如字段的访问级别、返回值类型、异常类型、注释等
+ 字段级别作用域：用与描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一写属性，如字段的访问级别、默认值、注释等
+ 还有一下其他注解作用域，如构造函数作用域和局部变量作用域。这些注解可以用来对构造函数和局部变量进行描述和注释



# 异常
## Java的异常
  

Java的异常体系主要基于Throwable及其子类。Throwable有两个重要的子类：Error和Exception，他们代表了不同类型的异常情况。

1. Error（错误）：表示运行环境的错误，错误是程序无法处理的严重问题，如虚拟机错误、动态链接库失效等。程序不应该尝试捕获这类错误。
2. Exception（异常）：表示程序本身可以处理的异常情况。异常分为两大类：
    1. 非运行时异常（受检异常）：这类异常在编译时就必须被捕获或声明抛出。它们通常是外部异常，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。
    2. 运行时异常（非受检异常）：这类异常特指Runtime Exception及其子类。它与Error一起构成了Java中的非受检异常家族，运行时异常由程序逻辑错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBouondsException）等。运行时异常时不需要在编译时强制捕获或声明的。



## Java异常处理有哪些
异常处理是通过使用try-catch语句块来捕获和处理异常。

Java中常用的异常处理方式：

+ try-catch语句块：用于捕获并处理可能抛出的异常
+ throw语句：用于手动抛出异常
+ throws关键字：用于在方法声明中声明可能抛出的异常类型
+ finally块：用于定义无论如何是否发生异常都会执行的代码块



## 抛出异常为什么不用throws？
如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。

具体讲解：

+ UncheckedException：未检查异常是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。如：NullPointerException、ArrayIndexOutOfBoundsException等
+ 捕获和处理异常：另一种常见情况是，在方法内部捕获了看看你抛出的异常，并在方法内部处理他们，而不是通过throws子句将他们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。



## try catch中的语句运行情况
try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。



## try{return "a"}finally{return "b"}这条语句返回啥
finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回“b”



# object
## Object类有那些方法
Java Object类是所有类的超类，默认提供11个核心方法，核心用于对象比较、哈希、字符串表示、线程同步等。

  最常用到的四equals方法，它的默认实现是比较两个对象的内存地址，也就是和==的效果一样，但实际开发中我们常需要按对象的内容比较，比如两个用户对象只要id相同就认为相等，这时候就需要重写equals。

  和equals配套的必须重写hashCode方法，因为Java的约定是如果两个对象equals返回true，它们的hashCode必须相等；如果hashCode不相等，equals一定返回false。如果只重写equals不重写hashCode，会导致对象在HashMap HashSet等集合中无法正确存储，比如两个id相同的User对象，equals返回true，但hashCode不同，会被当成两个不同元素存入集合。

  然后是toString方法，默认返回类名加@加对象的哈希码十六进制表示，比如User@1b6d3586，可读性很差。实际开发中重写它是为了返回对象的具体信息，方便日志打印和调试。

  接下来是getClass方法，它返回对象运行时的实际类对象，和编译时类型可能不同，而且这个方法不能重写。比如父类Animal的子类Dog，Animal animal=new Dog，animal.getClass返回的时Dog的类对象，常用于反射场景，比如通过getClass获取类的属性和方法。

  然后就是clone方法，用于创建对象的浅拷贝，默认是浅拷贝意味着如果对象有引用类型属性，拷贝后的对象和原对象会共享该引用属性。使用clone需要让类实现Cloneable接口，否则会抛出CloneNotSupportedException。

  还有notify和notifyAll方法，它们都是用于多线程同步的，和synchronized配合使用，作用是唤醒等待当前对象锁的线程。notify是随机唤醒一个等待线程，notifyAll是唤醒所有线程，比如生成者消费者模式中，生产者生产完数据后调用notifyAll，唤醒等待的消费者线程

  wait方法有三个重载，作用是让当前持有对象锁的线程释放锁并进入等待状态，直到被notify notifyAll唤醒或者等待时间到期。同样需要在synchronized同步块或方法中使用，否则会抛IllegalMonitorStateException

  最后是finalize方法，它是对象被垃圾回收器回收前会调用的方法，默认是空实现。但现在基本不推荐使用，因为它的执行时机不确定，可能很久才执行甚至不执行，而且可能导致对象复活，影响垃圾回收效率，Java9之后已经标记为过时，代替方案是使用try with resource或者PhantomReference来处理资源释放



## ==与equals有什么区别？
对于字符串变量来说，使用"=="和"equals"比较字符串时，其比较方法不同。"=="比较两个变量本身的值，即两个对象在内存中的首地址，"equals"比较字符串包含内容是否相同。 

  对于非字符串变量来说，如果没有对equals（）进行重写的话，"=="和"equals"方法的作用时相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。

即在字符串变量中

+ ==：比较的是两个字符串内存地址（堆地址）的数值是否相等，属于数值比较；
+ equals：比较的是两个字符串的内容，属于内容比较



## hashCode和equals方法有什么关系
在Java中，对于重写equals方法的类，通常也需要重写hashCode方法，并且需要遵循一下规定：

+ 一致性：如果两个对象使用equals方法比较结果为true，那么它们的hashCode值必须相同。也就是说，如果obj1.equals（obj2）返回true，那么obj1.hashCode（）必须等于obj2.hashCode（）。
+ 非一致性：如果两个对象的hashCode值相同，它们使用equals方法比较的结果不一定为true。

hashCode 和 equals 方法是紧密相关的，重写 equals 方法时必须重写 hashCode 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 hashCode方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等。



## Java里string的常用方法有那些？
+ 获取长度：int  length（）：返回字符串的长度（字符个数）
+ 判断内容：boolean equals（Object obj），用于比较两个字符串的内容是否完全相同（区分大小写）
+ 截取子串：String substring（int beginIndex），从指定索引开始截取到末尾
+ 去除空格：String trim（），去除字符串首尾的空白字符（空格、制表符等）
+ 替换内容：String replace（char oldChar，char newChar），替换所有指定字符
+ 判断空字符串：boolean isEmpty（），判断字符串长度是否为0（注意：null调用会报错，需先判空）



## String、StringBuffer、StringBuilder的区别和联系
1. 可变性：String是不可变的（Immutable），一旦创建，内容无法更改，每次修改都会生成一个新的对象。StringBuilder和StringBuffer是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象。
2. 线程安全性：String因为不可变，天然线程安全。StringBuilder不是线程安全的，适用于单线程环境。StringBuffer是线程安全的，其方法通过synchronized关键字实现同步，适用于多线程环境。
3. 性能：String性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。StringBuilder性能最高，因为他没有线程安全的开销，适合单线程下的字符串操作。StringBuffer性能略低于StringBuilder，因为它的线程安全机制引入了同步开销
4. 使用场景：如果字符串内容固定或不常变化，优先使用String。如果需要频繁修改字符串且在单线程环境下，使用StringBuilder。如果需要频繁修改字符串且在多线程环境下，使用StringBuffer



# Java新特性
## Java 8 有什么新特性
理解并注意Java8的新特性

|   特性名称 | 描述   | 实例或说明 |
| --- | --- | --- |
| Lambda表达式 | 简化匿名内部类，支持函数式编程 | （a,b）->a+b代替匿名类实现接口 |
| 函数式接口 | 仅含一个抽象方法的接口，可用@FunctionalInterface注解标记 | Runnable，Comparator或自定义接口:@FunctionalInterface interface MyFunc{void run（）;} |
| Stream API | 提供链式操作处理集合数据，支持并行处理 | list.stream().filter(x->x>0).collectors.toList()) |
| Optional类 | 封装可能为null的对象，减少空指针异常 | Optional.ofNullable(value).orElse("default") |
| 方法引用 | 简化Lambda表达式，直接引用现有方法 | System.out::println等价于x->System.out.println(x) |
| 接口的默认方法与静态方法 | 接口可定义默认实现和静态方法，增强扩展性 | interface A {<br/>default void print(){<br/>System.out.println("默认方法");<br/>}} |
| 并行数组排序 | 使用多线程加速数组排序 | Arrays.parallelSort(array) |
| 重复注解 | 允许同一位置多次使用相同注解 | @Repeatable注解配合容器注解使用 |
| 类型注解 | 注解可应用与更多位置（如泛型、异常等） | List<@NonNull String>list |
| CompletableFuture | 增强异步编程能力，支持链式调用和组合操作 | CompletableFuture.supply Async(()->"result").thenAccept(System.out::println) |




## 对于Lambda表达式的理解
Lambda表达式是一种简洁的语法，用于创建匿名函数，主要用与简化函数式接口（只有一个抽象方法的接口）的使用。

+ 传统的匿名类内部实现方式代码较为冗长，而Lambda表达式可以用更简洁的语法实现相同的功能。
+ Lambda表达式能够更清晰地表达代码的意图，尤其是在处理集合操作时，如过滤、映射等/
+ Lambda表达式使得Java支持函数式编程范式，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。
+ 缺点：会增加调试困难，因为Lambda表达式是匿名的，在调试时很难定位具体时那个Lambda表达式出现了问题。尤其是当Lambda表达式嵌套使用或者比较复杂时，调试难度会进一步增加



## Java中Stream的API介绍一下
Stream API提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。StreamAPI不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势并行处理。



## Stream流的并行API是什么
是ParallelStream。

并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的fork/join池来实现，即将一个任务拆分成多个"小任务"并行计算，再把多个"小任务"的结果合并成总的计算结果



## Stream串行流与并行流的主要区别：
对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I/O密集的，并且任务数相对比较大，那么直接用ParallelStream并不是很好的选择。



## completableFuture怎么用的
CompletableFuture是由Java8引入的，在Java8之前我们一般通过Future实现异步

二者的区别：

+ Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱。
+ CompletableFuture对Future进行了扩展，可以通过设置回调的方法处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。

CompletableFuture实现了两个接口：Future、CompletionStage。

+ Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤，这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行
+ 从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤

  一句话理解：CompletableFuture 是 Java 8 提供的"异步编程工具箱"，让你能像搭积木一样组合异步任务。

## Java21新特性
### 新语言特性
+ Switch语句的模式匹配：该功能在Java21中得到了增强。其允许在switch的case标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误
+ 数组模式（记录模式）：将模式匹配扩展到数组中，使得开发者能够在条件语句中更高效地解构和检查数组内容
+ 字符串模板（预览版）：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式

### 新并发特性方面
+ 虚拟线程：它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建其或ExecutorService来创建和使用虚拟线程
+ Scoped Values（范围值）:提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户绘画或配置设置。



# 序列化
## 怎么把一个对象从一个JVM转移到另一个JVM
+ 使用序列化和反序列化：将对象序列化为字节流，并将其发送到另一个JVM，然后在另一个JVM中反序列化字节流恢复对象。
+ 使用消息传递机制：利用消息传递机制，比如使用消息队列（如RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个JVM发送到另一个。这需要自定义协议来序列化对象并在另一个JVM中反序列化
+ 使用远程方法调用（RPC）:可以使用远程方法调用框架，如gRPC，来实现对象在不同JVM之间的传输。远程方法调用可以让你在分布式系统中调用远程JVM上的对象的方法
+ 使用共享数据库或缓存：将对象存储在共享数据库（如MySQL、PostgreSQL）或共享缓存（如Redis）中,让不同的JVM可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。



## 序列化和反序列化怎么实现
先讲讲Java默认的序列化，及其缺点：

Java默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等权限：

+ 如无法跨语言：其协议是Java语言强相关的二进制格式，包含了完整的类描述符（包名、类名、字段类型等），其他语言没有对应的类结构来解析
+ 容易被攻击：readObject是一个隐式构造器 ，反序列化时会自动调用。如果被序列化的类重写了此方法，或利用readResolve、writeReplace以及某些特定库（如commons-collections）的方法，可执行任意代码。
+ 序列化后的流太大：
    - 包含了大量元数据：每次序列化都写入了完整的类描述信息
    - 字段信息冗余：即使字段值为null或默认值，也会被写入
    - Java特定数据格式：对整数等类型的编码不够紧凑

故我会考虑主流序列化框架，比如FastJson、Protobuf来代替Java序列化。

如果追求性能的话，Protobuf序列化框架会比较合适，Protobuf的这种数据存储格式，不仅压缩存储数据的效果好，在编码和解码的性能方面也很高效。Protobuf的解码和编码过程结合.proto文件格式，加上Protocol Buffer独特的编码格式，只需要简单的数据运输以及位移等操作就可以完成编码与解码。故Protobuf的整体性能非常优秀 。



## 将对象转为二进制字节流具体怎么实现
（整理：像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的处理和解析协议，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和class文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象）

在Java中通过序列化对象流来完成序列化和反序列化：

+ ObjectOutputStream：通过writeObject()方法做序列化操作
+ ObjectInputStream：通过readObject()方法做反序列化操作

补充：只有实现了Serializable或Externalizabel接口的类的对象才能被序列化，否则抛出异常

实现对象序列化：

+ 让类实现Serializable接口：

```plain
import java.io.Serializable;

public class Myclass immplements Serializable{

}
```

+ 创建输出流并写入对象：

```plain
import java.io.FileOutputStream;
import java.io.ObjectOutputStram;

MyClass obj=new Myclass();
try{
  FileOutputStream fileOut= new FileOutputStream("object.ser");
  ObjectOutputStream out = new ObjectOutputStream(fileOut)；
  out.writeObject(obj);
  out.close();
  fileOut.close();
  } catch(IOException e){
  e.printStackTrace();
  }
}
```

实现对象反序列化：

+ 创建输入流并读取对象：

```plain
import java.io.FileInputStream;
import java.io.ObjectInputStream;

MyClass newObj = null;
try{
  FileInputStream fileIn=new FileInputStream("object.ser");
  ObjectInputStream in = new ObjectInputStream(fileIn);
  newObj = (MyClass)in.readObject();
  in.close();
  fileIn.close();
} catch(IOException | ClassNotFoundException e){
e.printStackTrace();
}
```

通过以上步骤，对象obj会被序列化并写入到文件"object.ser"中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObject。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable地才能被正确序列化。


# 设计模式
## volatile和sychronized如何实现单例模式
```plain
public class SingleTon{

  //volatile关键字修饰变量 防止指令重排序
  private static volatile SingleTon instance = null;
  private SingleTon(){}

  public static SingleTon getInstance(){
    if(instance == null){
      //同步代码块，只有在第一次获取对象地时候会执行到，第二次及以后访问时instance变量均非null故不会往下执行了  直接返回了
      synchronized(SingleTon.class){
        if(instance == null){
          instance=new SingleTon();
        }
      }
    }
    return instance;
  }
}
```

正确地双重检查锁定模式需要使用volatile。volatile包含两个功能。

+ 保证可见性：使用volatile定义地变量，将会保证对所有线程的可见性。
+ 禁止指令重排序优化
+ 由于volatile禁止对象创建时指令之间重排序，所以其他线程不会访问到一个为初始化的对象，从而保证安全性。



## 代理模式和匹配模式有什么区别
+ 目的不同：代理模式主要关注控制对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作
+ 结构不同：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色
+ 应用场景不同：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。



## 责任链模式使用场景是什么？
责任链模式的核心是让多个对象都有机会处理同一个请求，从而解耦请求的发送者和接受者。它的典型使用场景可以概括为：当你想避免将请求的发送者与特定接受者硬编码在一起，并希望动态地组织或调整处理流程时。

核心使用场景：

1. 请求需要经过多个对象按序处理（如审批/工作流系统）
2. 请求地接收者不明确或有多种可能（如事件/日志分级处理）
3. 需要动态指定或调整处理流程（如游戏中的伤害计算）

代码实例：

```plain
// 1. 抽象处理器
abstract class Approver {
    protected Approver nextApprover; // 指向下一个处理者
    protected String name;
    protected double approvalLimit; // 审批额度上限

    public Approver(String name, double limit) {
        this.name = name;
        this.approvalLimit = limit;
    }

    // 设置下一个处理者（构建链条的关键）
    public Approver setNext(Approver next) {
        this.nextApprover = next;
        return next; // 支持链式调用，如 manager.setNext(director).setNext(ceo)
    }

    // 处理请求的方法
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() <= this.approvalLimit) {
            // 自己能处理
            System.out.println(name + " 审批了采购单#" + request.getNumber() + "，金额: $" + request.getAmount());
        } else if (nextApprover != null) {
            // 自己处理不了，交给下一个人
            System.out.println(name + " 无法审批，转交上级 -> " + nextApprover.name);
            nextApprover.processRequest(request);
        } else {
            // 没人能处理了（链条终点）
            System.out.println("采购单#" + request.getNumber() + " 金额 $" + request.getAmount() + " 过高，无人能审批！");
        }
    }
}

// 2. 具体处理器
class Manager extends Approver {
    public Manager(String name) { super(name, 5000); }
}

class Director extends Approver {
    public Director(String name) { super(name, 20000); }
}

class CEO extends Approver {
    public CEO(String name) { super(name, 100000); }
}

// 3. 请求类
class PurchaseRequest {
    private int number;
    private double amount;
    // 构造函数、getter省略...
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        // 构建责任链：经理 -> 总监 -> CEO
        Approver manager = new Manager("张经理");
        Approver director = new Director("李总监");
        Approver ceo = new CEO("王总裁");

        manager.setNext(director).setNext(ceo);

        // 发送不同金额的请求
        PurchaseRequest request1 = new PurchaseRequest(1001, 3000);
        PurchaseRequest request2 = new PurchaseRequest(1002, 15000);
        PurchaseRequest request3 = new PurchaseRequest(1003, 80000);
        PurchaseRequest request4 = new PurchaseRequest(1004, 200000);

        manager.processRequest(request1); // 张经理处理
        manager.processRequest(request2); // 张经理转交 -> 李总监处理
        manager.processRequest(request3); // 张经理转交 -> 李总监转交 -> 王总裁处理
        manager.processRequest(request4); // 链条传递到终点，无人能处理
    }
}
```



## 介绍一下策略模式和责任链模式，分别用在哪些场景？
共同之处：这两个设计模式都属于行为模式，而且在实际开发中，它们往往都是为了解决同一个痛点：如何消除代码中复杂的"if-else"或"switch-case"逻辑，从而让系统更易于扩展。

+ 策略模式：动态切换"如何做"
    - 定义：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。它让算法的变化独立于使用它的客户端
    - 核心场景：当系统需要在多种算法或行为中动态选择一种时。
    - 经典用例：支付系统（用户在支付方式中选择一种）、数据导出（将一份数据导出为不同的格式）、导航计算（选择不同的路径）、折扣计算（满减、打折、返现等不同的促销策略）。
+ 责任链模式：传递请求“谁来做”
    - 定义：将多个处理对象连成一条链，请求沿链传递。每个处理者决定自己处理或传递给下一个。它解耦了请求的发送者和接受者。
    - 核心场景：当一个请求需要经过多个对象按序处理，或接收者不明确需要动态寻找时。
    - 经典用例：审批工作流、Web过滤器链、日志/异常处理、GUI事件传播



# I/O
## Java怎么实现网络IO高并发编程？
可以用Java NIO，是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。

补充：

+ 传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据，如果使用BIO要想要并发处理多个客户端的I/O，那么会使用多线程模式，一个线程专门处理一个客户端IO，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能
+ NIO时基于I/O多路复用实现的，它可以只用一个线程处理多个客户端I/O，如果你需要同时管理成千上万的链接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。



## BIO、NIO、AIO区别是什么
+ BIO(blocking IO)：就是传统的java.io包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读完动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是IO的效率和拓展性很低。容易成为应用性能瓶颈
+ NIO(non-blocking IO)：Java1.4引入的java.nio包，提供了Channel、Selector、Buffer等新抽象，可以构建多路复用的、同步非阻塞IO程序，同时提供了更接近操作系统底层高性能的数据操作方式
+ AIO（Asynchronous IO）:是Java1.7之后引入的包，是NIO的升级版本，提供了异步非阻塞的IO操作方式，所以人们叫它AIO，异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

简答概括就是：

+ BIO：一个连接一个线程，全程阻塞
+ NIO：一个线程处理多个连接，轮询事件
+ AIO：一个线程处理多个连接，回调通知



## NIO是怎么实现的
NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLockINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。

同步的核心就是Selector(I/O多路复用)，Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待

NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。

Selector(选择区)用于 监听多个通道的事件(比如：连接打开，数据到达)。因此，单个线程可以监听多个数据通道。



从另一种层面的回答：  
Java NIO的实现，本质时通过Selector这个"中央事件监控器"，利用操作系统提供的epoll/kqueue等多路复用系统调用，实现了"一个线程监控万级连接，只处理真正有数据到来的连接"的高效模型。它避免了BIO中为每个连接创建一个线程的巨大开销，这是支撑现代高并发服务器的核心技术基石。



## 有哪个框架用到了NIO
Netty，其主要是用于构建高性能网络服务器/客户端，特点为NIO领域事实标准，异步事件驱动，API友好，广泛用于RPC、游戏、即时通讯。

追问NIO的实现

Netty 的 I/O 模型基于同步非阻塞I/O实现，其核心是依赖于 NIO 提供的多路复用器 Selector。在 Linux 系统上采用 epoll 模式后，每个 EventLoop 线程可以负责一个 Selector 的轮询。当有连接或数据就绪时，EventLoop 作为事件分发器，会将 I/O 事件分发给对应的 ChannelPipeline 中的处理器进行处理。

事件分发器的架构主要有两种设计模式：Reactor 和 Proactor。

+ Reactor 模式 基于同步非阻塞I/O。应用程序负责监听就绪事件，并在事件就绪后亲自完成数据的读写操作。它的实现相对直观，资源消耗可控。为了避免耗时的业务逻辑阻塞网络线程，现代 Reactor 实现（如 Netty）的通用做法是：将网络I/O处理与业务处理分离——EventLoop 线程仅负责高效的字节流读写和编解码，而将具体的业务逻辑（如数据库查询、复杂计算）提交给独立的业务线程池执行，从而保证高并发下的响应能力。
+ Proactor 模式 则基于异步I/O。应用程序发起异步读写请求后，由操作系统内核负责完成整个I/O操作（包括数据在内核与用户空间之间的拷贝），操作完成后才通知应用程序。这种模式理论上效率更高，但实现复杂，且严重依赖操作系统底层的异步I/O支持。



目前，主流的跨平台高性能网络框架（包括 Netty、Nginx）主要采用 Reactor 模式，并依赖 epoll、kqueue 等高效的多路复用系统调用来实现。这是因为在 Linux 等主流服务器操作系统上，成熟的异步I/O支持（如针对网络套接字的 AIO）长期不够完善，而 Reactor 模式凭借其成熟的生态、卓越的性能和良好的可调试性，已成为业界构建百万级并发应用的事实标准。



# 其他
## 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？
可以使用Comparable接口来实现按照分数排序，在按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。

```plain
public class Student implements Comparable<Student>{
  private int id;
  private int score;

  @Override
  public int compareTo(Student other){
    if(this.score!=other.score){
      return Integer.compare(other.score,this.score);
    }else{
      return Integer.compare(this.id,other.id);
    }
  }
}
```

然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：

```plain
List<Student> students=new ArrayList<>();
Collections.sort(students);//使用Collections.sort(students)时，会按照Student的compareTo方法进行排序。
```



## Native方法解释一下
在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。

在Java类中，native方法看起来与其他方法相似，只是其他方法体由native关键字替代，没有实际的实现代码。例如：

```plain
public class NativeExample{
  public native void nativeMethod();
}
```

如果要实现native方法，需要完成以下步骤：

1. 生成JNI头文件：使用javah工具从你的Java类生成C/C++的头文件，这头文件包含了所有native方法的原型
2. 编写本地代码：使用C/C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。
3. 编译本地代码：将C/C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）
4. 加载本地库：在Java程序中，使用System.loadLibrary()方法加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了



## Java进程是怎么跟操作系统交互的
Java进程通过**JVM（Java虚拟机）** 与操作系统交互：JVM作为核心中介，将Java代码中的操作（如文件读写、网络通信、线程创建）转换为对操作系统**系统调用**的请求。例如，当Java程序执行I/O或内存分配时，JVM会通过其本地方法库（利用JNI技术）调用底层C/C++代码，这些代码最终向操作系统内核发起 `read`、`write`、`mmap` 等系统调用，从而访问硬件资源（CPU、内存、磁盘、网络）。同时，JVM依赖操作系统管理线程调度、内存映射等基础功能，而操作系统则将处理结果或事件（如数据就绪、中断）通过JVM返回给Java应用程序。整个过程确保了Java的跨平台性，所有底层交互均由JVM统一封装和处理。




