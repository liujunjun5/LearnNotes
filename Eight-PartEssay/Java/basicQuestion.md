# 概念
## Java的特点
+ 平台无关性：即一次编译，到处运行
    - Java编译器将源代码编译成字节码，该字节码可以在任何安装了Java虚拟机的系统上运行。
+ 面向对象编程：将事物抽象成为对象，对象具有属性和行为。
    - 面相对象的特性使得代码更易于维护和重用，包括类、对象、继承、多态、抽象和封装。
+ 内存管理：有着自动垃圾回收机制，无需程序员手动进行垃圾回收，自动管理内存和回收不再使用的对象，减少了内存溢出和内存泄漏等问题。



## Java的优势和劣势
### 优势
+ 一次编写，到处运行。
+ 是面向对象编程，有着强大的生态（如Java SPring等），社区支持，企业应用广泛。
+ 内存管理：拥有自动垃圾回收机制。
+ 支持多线程，内置线程机制，方便并发编程。
+ Java的安全模型：如沙箱机制，适合网络环境
+ 稳定性较好：企业级应用长期使用，版本更新也较注重向后兼容

### 劣势
+ 性能开销较大，启动时间较长（如在微服务场景下）
+ 语言繁琐，虽然有了lambda编程，但还是不如Python简洁。
+ 内存消耗：JVM本身也是占用内存，对于资源有限的环境可能不太友好。
+ 还有面向对象过于严格，有时候写简单程序反而麻烦，虽然在Java8以后引入了函数式编程，但不如其他语言自然。
+ 开发效率可能不如动态语言（如Python，Java需要更多的代码），编译过程也可能拖慢开发节奏。



## Java为什么是跨平台的
Java支持跨平台，主要依赖于JVM

+ JVM是一个软件，在不同的平台上又不同的版本。Java源码经过编译后会生成一种字节码.class文件，JVM可以将字节码翻译为特定平台下的机器码，然后运行。



## JVM、JDK、JRE三者关系
JDK包含JRE，JRE包含JVM

+ JVM：JVM是Java虚拟机，是Java程序运行的环境，将Java字节码解释或编译为机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java具有跨平台性。
+ JDK是Java开发工具包，是开发Java所需要的工具集合。他包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具。
+ JRE是Java程序运行所需要的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含 开发工具，只提供Java程序运行所需的运行环境。



## JVM和Java有什么区别
+ Java是编程语言，而JVM是平台。一个是写代码的工具，一个是跑代码的环境。二者分工不同但相互配合。
    - 即Java是一门编程语言，JVM是用来运行Java程序的一个平台或者是运行环境。
    - JVM不止能够运行Java。因为JVM执行的是字节码，所以想Kotlin/Scala这些语言，虽然在语法上跟Java不一样，但是在编译后也是生成Java字节码，同样可以在JVM上运行。故JVM现在已经不是Java专属了，而是整个JVM语言生态的基础平台。



## 为什么Java解释和编译都有
首先Java在经过编译后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。

+ 编译性：Java源代码首先被编译成字节码，JIT会把编译过的机器码保存起来，以备下次使用
+ 解释性：JVM中一个方法调用计数器，当累计计数大于一定值的时候，就是用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。

故Java既是编译型也是解释型语言，默认采用的是解释器和编译器混合的模式。



## JVM是什么
JVM是Java虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。

JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行“的原因。



## 编译型语言和解释型语言的区别？
编译型语言和解释型语言的区别在于：

+ 编译型语言：在程序执行之前，整个源代码会被编译成字节码或是机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性差
+ 解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行文件，跨平台性好，但执行速度相对较慢。



## Python和Java区别是什么？
+ Python是解释型语言，在执行时会逐行解释代码并执行
+ Java是一种已编译型的编程语言，会编译生成字节码文件，在将文件交由JVM虚拟机执行。



## 值传递和引用传递的区别？
在Java中，参数传递只有值传递，不存在真正的“应用传递”，核心区别在于传递的是“值的副本”，还是“引用的副本”。

+ 值传递传递的是实际值的副本，适用于基本数据类型，修改方法内的参数副本，并不会影响原变量的值。
+ 引用传递传递的是对象的引用副本，这两个引用都是指向同一个对象，因此通过副本修改对象内部数据，会影响原对象。但如果修改副本引用的指向（如重新赋值），则不会影响原引用的指向。

简单来说，Java的所有参数传递都是值传递：

+ 基本数据类型传递“值传递”，修改副本不影响原值。
+ 引用类型传递“引用副本”，通过副本可修改对象内容，但无法修改原引用的指向。



# 数据类型
## 八种基本数据类型
Java支持的数据类型可以分为两类：基本数据类型和引用数据类型

基本数据类型分为八种，可以分为三类：

+ 数值型：
    - 正数类型：byte ，short，int，long
    - 浮点数类型：float，double
+ 字符型：char
+ 布尔型：boolean

补充：

| 数据类型 | 占用大小 | 位数 | 取值范围 | 默认值 | 描述 |
| --- | --- | --- | --- | --- | --- |
| byte<br/> | 1 | 8 | -2^7~(2^7-1) | 0 | 是最小的整数类型，适用于节省内存，如在处理文件或网络流时存储小范围整数数据<br/> |
| short | 2 | 16 | -2^16~2^16-1 | 0 | 较少使用，通常用于在需要节省内存且数值范围在该区间的场景 |
| int | 4 | 32 | -2^32~2^32-1 | 0 | 最常用的整数类型，可满足大多数日常编程中整数计算的需求 |
| long | 8 | 64 | -2^64~2^641 | 0L | 用于表示非常大的整数，当int类型无法满足需求时使用，定义时数值后需加L或l |
| float | 4 | 32 | 1.4E-45到3.4028235E38 | 0.0f | 单精度浮点数，用于表示小数，精度相对较低，定义时数值后需加F或f |
| double | 8 | 64 | 4.9E-324~1.7976931348623157E308 | 0.0d | 双精度浮点数，精度比float高，Java中表示小数的默认类型 |
| char | 2 | 16 | ‘\u0000'(0)~'\uffff'(65535) | '\u0000' | 用于表示单个字符，采用Unicode编码，可表示各种语言的字符。 |
| boolean | 无明确字节大小（理论上1位） | 无明确位数 | true或false | false | 用于逻辑判断，只用两个取值，常用于条件判断和循环控制等逻辑场景 |


注意：八种基本数据类型的包装类：除了char的时Character、int类型的Integer，其他都是首字母大写。



## int和long是多少位，多少字节的
int是32位，4字节；long是64位，8字节。

二者都是有符号的。



## long和int可以相互转换吗?
可以的，Java中的long和int是可以相互转换的。由于long类型的范围比int类型大，故将int转换为long是安全的，将long类型转换为int类型可能会导致数据丢失或溢出。

将int类型转换位long可以直接赋值或强制类型转换来来实现。

将long类型转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。



## 数据类型转换方式有哪些？
+ 自动类型转换：如将int类型转换为long类型，就可以直接赋值
+ 强制类型转换：如将long类型转换为int类型，就需要使用强制类型转换
+ <font style="color:#DF2A3F;">字符串转换：Java提供了将字符串转换为其他数值类型的方法。</font>
+ <font style="color:#DF2A3F;">数值之间的转换：Java提供了一些数值之间的转换方法，如将整数类型转换为字符型，将字符型装换位数值型</font>

<font style="color:#DF2A3F;"></font>

## <font style="color:#000000;">类型互转会出现什么问题</font>
1. 基本数据类型之间的转换可能会出现数据丢失、数据溢出或精度损失。
2. <u>应用对象之间的转换可能会出现的问题：向上转换是自动进行的，而且是安全的；向下转换需要手动进行，并且存在风险（当进行向下转型时，Java会检查是否与目标类型兼容。如果不兼容，就会抛出Class CastException）。需要使用instanceof进行检查</u>

## 为什么用bigDecimal不用douoble
- double会出现精度丢失问题，double执行的是二进制浮点运算，即二进制表示小数时只能够表示能够用1/（2^n）之和的任意组合，故他无法很好的表示0.1这种小数，因为0.1不能够表示成为1/（2^n）之和的形式，就像十进制无法准确的表示三分之一。
- 而bigDecimal是精确计算，一般牵扯到金钱的计算，都是使用Decimal，使用Big Decimal可以确保十进制的数值计算，避免了使用double可能出现的舍入误差，但需要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数作为参数，以避免精度丢失。

## 装箱和拆箱是什么
装箱是将方法和属性进行封装，拆箱则是与之相反的操作。将int类型转换位Integer包装类，是装箱；将Integer包装类转换位int类型，则是拆箱。
（即装箱和拆箱是将基本数据类型和对应的包装类之间进行转换的过程。）
补充：
- 自动装箱主要发生在两种情况，一种是赋值时（所有转换都是编译器来完成），另外一种是在方法调用时（在调用方法时，我们可以传入原始的数据类型，或者时对象，编译器会帮我们进行转换）。
- 自动装箱的弊端，在一个循环中进行自动装箱操作的情况下，可能会创建多余的对象，影响程序的性能。

## Java为什么要有Integer
（先从两个方面去思考，一是将int类型包装成Integer对象，可以把属性也就是数据和这些数据的处理方法结合在一起。另一个方面就是Java中绝大部分方法和类都是用来处理类类型对象的，就比如Array List集合类就只能以类作为他的存储对象）。
- 一方面将int类型包装成Integer对象，可以把这些数据和处理这些数据的方法结合在一起。
- 另一方面，就是Java中的绝大部分方法和类都是用来处理类类型对象的。主要是从一下几个方面进行说明：
  - 一个就是泛型中的引用，在Java中，泛型只能使用引用类型，而不能使用基本类型，因此，如果要在泛型中使用int类型，必须使用Integer包装类。
  - 另一个就是在转换中的应用，如果要将int类型转换位String类型，就需要先将其转换位Integer包装类，在通过Integer包装类转换位String类型。
  - 还有一个就是集合的应用，在Java集合中只能存储对象，而不能存储基本数据类型；就例如Array List集合类中只能以类作为他的存储对象。

## Integer相比int有什么优点
（可以联合Java为什么要有Integer这个问题进行联合记忆）
1. 面向对象的特性
  a. Integer是对象，可以参与面向对象的操作（如作为方法参数传递时按引用传递）
  b. 可以调用其他方法（如Integer.parseInt（））
2. 泛型支持
  a. 可以用于集合框架（如List<Integer>），因为泛型不支持基本类型
  b. 支持作为泛型类型参数
3. 特殊值支持
  a. 可以表示null值，适用于数据可能缺失的场景（如数据库查询结果）
4. 功能扩展
  a. 提供丰富的工具方法：进制转换、比较、类型转换等
  b. 常量支持：Integer.MAX_VALUE、Integer.MIN_VALUE 
5. 自动装箱/拆箱
  a. Java5+支持与int自动转换，兼顾便利性和功能
6. 缓存优化
  a. 默认缓存-128到127的Integer对象，提高常用数值的性能

追求性能、常规计算：使用int；需要对象特性、集合操作、可能为空：使用Integer。
同时null值是无法自动拆箱的。

## 那为什么还要保留int类型
- 一是包装类作为引用类型，对象的引用和对象本身是分开存储的，而基本类型数据、变量对应的内存块直接存储数据本身。
- 二是基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启应用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的四倍。
综上所述，不管是读写效率，还是存储效率，基本类型，都比包装类高效。

